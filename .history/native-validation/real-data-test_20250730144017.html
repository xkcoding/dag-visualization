<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çœŸå®æ•°æ® DAG éªŒè¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f7fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .svg-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
            overflow: auto;
            height: 600px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: #1890ff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #40a9ff;
            transform: translateY(-1px);
        }
        
        .file-input {
            display: none;
        }
        
        .file-label {
            background: #52c41a;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: inline-block;
        }
        
        .file-label:hover {
            background: #73d13d;
            transform: translateY(-1px);
        }
        
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid;
        }
        
        .status.success {
            background: #f6ffed;
            color: #52c41a;
            border-color: #b7eb8f;
        }
        
        .status.error {
            background: #fff2f0;
            color: #ff4d4f;
            border-color: #ffccc7;
        }
        
        .status.info {
            background: #e6f7ff;
            color: #1890ff;
            border-color: #91d5ff;
        }
        
        /* SVG æ ·å¼ */
        .dag-node {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dag-node:hover {
            filter: brightness(1.1);
            stroke-width: 3;
        }
        
        .dag-node.selected {
            stroke: #ff4d4f;
            stroke-width: 3;
        }
        
        .node-prompt {
            fill: #52c41a;
            stroke: #389e0d;
        }
        
        .node-llm {
            fill: #faad14;
            stroke: #d48806;
        }
        
        .node-http {
            fill: #ff4d4f;
            stroke: #cf1322;
        }
        
        .node-code {
            fill: #722ed1;
            stroke: #531dab;
        }
        
        .node-text {
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 10px;
            font-weight: bold;
            pointer-events: none;
        }
        
        .node-text.dark {
            fill: #000;
        }
        
        .dag-edge {
            stroke: #595959;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        
        .dag-edge.highlighted {
            stroke: #ff4d4f;
            stroke-width: 3;
        }
        
        h1 {
            color: #262626;
            margin: 0;
        }
        
        h3 {
            color: #8c8c8c;
            margin: 5px 0;
            font-weight: normal;
        }
        
        .stats {
            background: #f0f2f5;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .info-panel {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š çœŸå®æ•°æ® DAG éªŒè¯</h1>
            <h3>åŠ è½½ dag-question-rewrite-rerank.json æ–‡ä»¶è¿›è¡Œå¯è§†åŒ–éªŒè¯</h3>
            <div class="stats" id="stats">
                ç­‰å¾…åŠ è½½æ•°æ®...
            </div>
        </div>
        
        <div class="svg-container">
            <svg id="dag-svg" width="100%" height="550" viewBox="0 0 1200 550">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#595959" />
                    </marker>
                </defs>
                
                <g id="edges-group"></g>
                <g id="nodes-group"></g>
            </svg>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="file-input" class="file-label">ğŸ“ åŠ è½½ JSON æ–‡ä»¶</label>
                <input type="file" id="file-input" class="file-input" accept=".json" onchange="loadJSONFile(event)">
                <button onclick="loadFromParent()">ğŸ”— åŠ è½½çˆ¶ç›®å½•æ•°æ®</button>
                <button onclick="testLayouts()">ğŸ“ åˆ‡æ¢å¸ƒå±€</button>
                <button onclick="exportData()">ğŸ’¾ å¯¼å‡ºé…ç½®</button>
                <button onclick="clearCanvas()">ğŸ§¹ æ¸…ç©º</button>
            </div>
            
            <div id="status" class="status info">
                è¯·é€‰æ‹© dag-question-rewrite-rerank.json æ–‡ä»¶æˆ–ç‚¹å‡»"åŠ è½½çˆ¶ç›®å½•æ•°æ®"
            </div>
            
            <div class="info-panel" id="node-info" style="display: none;">
                <strong>èŠ‚ç‚¹ä¿¡æ¯:</strong>
                <div id="node-details"></div>
            </div>
        </div>
    </div>

    <script>
        class RealDataDAG {
            constructor(svgId) {
                this.svg = document.getElementById(svgId);
                this.nodesGroup = document.getElementById('nodes-group');
                this.edgesGroup = document.getElementById('edges-group');
                this.nodes = [];
                this.edges = [];
                this.selectedNode = null;
                this.rawData = null;
                
                this.nodeTypes = {
                    'PROMPT_BUILD': { class: 'node-prompt', textClass: 'node-text' },
                    'CALL_LLM': { class: 'node-llm', textClass: 'node-text dark' },
                    'HTTP_REQUEST': { class: 'node-http', textClass: 'node-text' },
                    'CODE_EXEC': { class: 'node-code', textClass: 'node-text' }
                };
            }
            
            // è§£æçœŸå®çš„ DAG JSON æ•°æ®
            parseRealDAGJson(dagData) {
                this.rawData = dagData;
                const nodes = [];
                const edges = [];
                
                console.log('è§£æ DAG æ•°æ®:', dagData);
                
                if (dagData.tasks) {
                    dagData.tasks.forEach((task, index) => {
                        const nodeType = this.extractNodeType(task['@type']);
                        const nodeId = task.taskId || `task_${index}`;
                        
                        nodes.push({
                            id: nodeId,
                            type: nodeType,
                            label: `${nodeType}`,
                            taskType: task.taskType,
                            atType: task['@type'],
                            originalTask: task,
                            x: 0, y: 0
                        });
                        
                        // è§£æä¾èµ–å…³ç³»
                        if (task.dependencies && Array.isArray(task.dependencies)) {
                            task.dependencies.forEach(dep => {
                                edges.push({
                                    source: dep,
                                    target: nodeId
                                });
                            });
                        }
                    });
                }
                
                console.log(`è§£æå®Œæˆ: ${nodes.length} ä¸ªèŠ‚ç‚¹, ${edges.length} æ¡è¾¹`);
                return { nodes, edges };
            }
            
            extractNodeType(atType) {
                if (atType.includes('TemplateTransform')) return 'PROMPT_BUILD';
                if (atType.includes('LLM')) return 'CALL_LLM';
                if (atType.includes('HttpRequest')) return 'HTTP_REQUEST';
                if (atType.includes('Code')) return 'CODE_EXEC';
                return 'UNKNOWN';
            }
            
            // æ”¹è¿›çš„å±‚æ¬¡å¸ƒå±€ç®—æ³•
            calculateHierarchicalLayout(nodes, edges) {
                if (nodes.length === 0) return nodes;
                
                // è®¡ç®—å…¥åº¦
                const inDegree = {};
                const outEdges = {};
                nodes.forEach(node => {
                    inDegree[node.id] = 0;
                    outEdges[node.id] = [];
                });
                
                edges.forEach(edge => {
                    if (inDegree[edge.target] !== undefined) {
                        inDegree[edge.target]++;
                    }
                    if (outEdges[edge.source]) {
                        outEdges[edge.source].push(edge.target);
                    }
                });
                
                // åˆ†å±‚
                const layers = [];
                let currentLayer = nodes.filter(node => inDegree[node.id] === 0);
                const processed = new Set();
                
                while (currentLayer.length > 0) {
                    layers.push([...currentLayer]);
                    currentLayer.forEach(node => processed.add(node.id));
                    
                    const nextLayer = [];
                    currentLayer.forEach(node => {
                        outEdges[node.id].forEach(targetId => {
                            inDegree[targetId]--;
                            if (inDegree[targetId] === 0 && !processed.has(targetId)) {
                                const targetNode = nodes.find(n => n.id === targetId);
                                if (targetNode && !nextLayer.includes(targetNode)) {
                                    nextLayer.push(targetNode);
                                }
                            }
                        });
                    });
                    
                    currentLayer = nextLayer;
                }
                
                // å¤„ç†å‰©ä½™èŠ‚ç‚¹ï¼ˆå¯èƒ½æœ‰å¾ªç¯ä¾èµ–ï¼‰
                const remaining = nodes.filter(node => !processed.has(node.id));
                if (remaining.length > 0) {
                    layers.push(remaining);
                }
                
                // åº”ç”¨å¸ƒå±€
                const spacingX = 140;
                const spacingY = 80;
                const startX = 70;
                const startY = 50;
                
                layers.forEach((layer, layerIndex) => {
                    layer.forEach((node, nodeIndex) => {
                        node.x = startX + layerIndex * spacingX;
                        node.y = startY + nodeIndex * spacingY;
                    });
                });
                
                return nodes;
            }
            
            // ç½‘æ ¼å¸ƒå±€
            calculateGridLayout(nodes) {
                const cols = Math.ceil(Math.sqrt(nodes.length));
                const spacingX = 140;
                const spacingY = 80;
                
                nodes.forEach((node, index) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    node.x = 70 + col * spacingX;
                    node.y = 50 + row * spacingY;
                });
                
                return nodes;
            }
            
            // æ¸²æŸ“èŠ‚ç‚¹
            renderNodes() {
                this.nodesGroup.innerHTML = '';
                
                this.nodes.forEach(node => {
                    const nodeConfig = this.nodeTypes[node.type] || this.nodeTypes['UNKNOWN'];
                    
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'dag-node');
                    g.setAttribute('data-id', node.id);
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', node.x - 60);
                    rect.setAttribute('y', node.y - 25);
                    rect.setAttribute('width', 120);
                    rect.setAttribute('height', 50);
                    rect.setAttribute('rx', 8);
                    rect.setAttribute('class', nodeConfig.class);
                    rect.setAttribute('stroke-width', 2);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y - 5);
                    text.setAttribute('class', nodeConfig.textClass);
                    text.textContent = node.type;
                    
                    const idText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    idText.setAttribute('x', node.x);
                    idText.setAttribute('y', node.y + 10);
                    idText.setAttribute('class', nodeConfig.textClass);
                    idText.setAttribute('font-size', '8');
                    idText.textContent = node.id.length > 12 ? node.id.substring(0, 12) + '...' : node.id;
                    
                    g.addEventListener('click', () => this.selectNode(node.id));
                    
                    g.appendChild(rect);
                    g.appendChild(text);
                    g.appendChild(idText);
                    this.nodesGroup.appendChild(g);
                });
            }
            
            // æ¸²æŸ“è¿çº¿
            renderEdges() {
                this.edgesGroup.innerHTML = '';
                
                this.edges.forEach(edge => {
                    const sourceNode = this.nodes.find(n => n.id === edge.source);
                    const targetNode = this.nodes.find(n => n.id === edge.target);
                    
                    if (sourceNode && targetNode) {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        
                        // è®¡ç®—è¿çº¿è·¯å¾„
                        const startX = sourceNode.x + 60;
                        const startY = sourceNode.y;
                        const endX = targetNode.x - 60;
                        const endY = targetNode.y;
                        
                        // ä½¿ç”¨è´å¡å°”æ›²çº¿ä½¿è¿çº¿æ›´ç¾è§‚
                        const midX = (startX + endX) / 2;
                        const d = `M ${startX} ${startY} Q ${midX} ${startY} ${endX} ${endY}`;
                        
                        path.setAttribute('d', d);
                        path.setAttribute('class', 'dag-edge');
                        path.setAttribute('data-source', edge.source);
                        path.setAttribute('data-target', edge.target);
                        
                        this.edgesGroup.appendChild(path);
                    }
                });
            }
            
            // é€‰æ‹©èŠ‚ç‚¹å¹¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            selectNode(nodeId) {
                // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
                document.querySelectorAll('.dag-node').forEach(node => {
                    node.classList.remove('selected');
                });
                
                document.querySelectorAll('.dag-edge').forEach(edge => {
                    edge.classList.remove('highlighted');
                });
                
                // é€‰æ‹©æ–°èŠ‚ç‚¹
                const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                const nodeData = this.nodes.find(n => n.id === nodeId);
                
                if (nodeElement && nodeData) {
                    nodeElement.classList.add('selected');
                    this.selectedNode = nodeId;
                    
                    // é«˜äº®ç›¸å…³è¿çº¿
                    document.querySelectorAll(`[data-source="${nodeId}"], [data-target="${nodeId}"]`).forEach(edge => {
                        edge.classList.add('highlighted');
                    });
                    
                    // æ˜¾ç¤ºèŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯
                    this.showNodeInfo(nodeData);
                    
                    updateStatus(`å·²é€‰ä¸­èŠ‚ç‚¹: ${nodeId}`, 'info');
                }
            }
            
            showNodeInfo(nodeData) {
                const infoPanel = document.getElementById('node-info');
                const detailsDiv = document.getElementById('node-details');
                
                const task = nodeData.originalTask;
                const dependencies = task.dependencies || [];
                const dependents = this.edges.filter(e => e.source === nodeData.id).map(e => e.target);
                
                detailsDiv.innerHTML = `
                    <strong>ID:</strong> ${nodeData.id}<br>
                    <strong>ç±»å‹:</strong> ${nodeData.type}<br>
                    <strong>ä»»åŠ¡ç±»å‹:</strong> ${nodeData.taskType || 'N/A'}<br>
                    <strong>åŸå§‹ç±»å‹:</strong> ${nodeData.atType}<br>
                    <strong>ä¾èµ–æ•°é‡:</strong> ${dependencies.length}<br>
                    <strong>è¢«ä¾èµ–æ•°é‡:</strong> ${dependents.length}<br>
                    ${dependencies.length > 0 ? `<strong>ä¾èµ–:</strong> ${dependencies.join(', ')}<br>` : ''}
                    ${dependents.length > 0 ? `<strong>è¢«ä¾èµ–:</strong> ${dependents.join(', ')}<br>` : ''}
                `;
                
                infoPanel.style.display = 'block';
            }
            
            loadData(nodes, edges, layoutType = 'hierarchical') {
                this.nodes = nodes;
                this.edges = edges;
                
                if (layoutType === 'hierarchical') {
                    this.calculateHierarchicalLayout(this.nodes, this.edges);
                } else {
                    this.calculateGridLayout(this.nodes);
                }
                
                this.render();
                this.updateStats();
            }
            
            render() {
                this.renderNodes();
                this.renderEdges();
            }
            
            clear() {
                this.nodes = [];
                this.edges = [];
                this.rawData = null;
                this.nodesGroup.innerHTML = '';
                this.edgesGroup.innerHTML = '';
                this.selectedNode = null;
                document.getElementById('node-info').style.display = 'none';
                this.updateStats();
            }
            
            updateStats() {
                const stats = document.getElementById('stats');
                stats.textContent = `èŠ‚ç‚¹: ${this.nodes.length} | è¿çº¿: ${this.edges.length} | ä»£ç : ~4KB | æ€§èƒ½: åŸç”Ÿæ¸²æŸ“`;
            }
            
            exportConfiguration() {
                if (!this.rawData) {
                    return null;
                }
                
                const config = {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        totalNodes: this.nodes.length,
                        totalEdges: this.edges.length
                    },
                    nodes: this.nodes.map(node => ({
                        id: node.id,
                        type: node.type,
                        position: { x: node.x, y: node.y },
                        taskType: node.taskType,
                        atType: node.atType
                    })),
                    edges: this.edges,
                    originalData: this.rawData
                };
                
                return config;
            }
        }
        
        // å…¨å±€å˜é‡
        let dag = null;
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            dag = new RealDataDAG('dag-svg');
            updateStatus('çœŸå®æ•°æ® DAG éªŒè¯å™¨åˆå§‹åŒ–å®Œæˆ', 'success');
        });
        
        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // åŠ è½½ JSON æ–‡ä»¶
        function loadJSONFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            updateStatus('æ­£åœ¨è¯»å–æ–‡ä»¶...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    const { nodes, edges } = dag.parseRealDAGJson(jsonData);
                    dag.loadData(nodes, edges, 'hierarchical');
                    updateStatus(`æ–‡ä»¶åŠ è½½æˆåŠŸ: ${nodes.length} ä¸ªèŠ‚ç‚¹, ${edges.length} æ¡è¾¹`, 'success');
                } catch (error) {
                    updateStatus(`æ–‡ä»¶è§£æå¤±è´¥: ${error.message}`, 'error');
                    console.error('JSON è§£æé”™è¯¯:', error);
                }
            };
            
            reader.readAsText(file);
        }
        
        // å°è¯•åŠ è½½çˆ¶ç›®å½•çš„æ•°æ®æ–‡ä»¶
        async function loadFromParent() {
            updateStatus('æ­£åœ¨å°è¯•åŠ è½½çˆ¶ç›®å½•æ•°æ®...', 'info');
            
            try {
                const response = await fetch('../dag-question-rewrite-rerank.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                const { nodes, edges } = dag.parseRealDAGJson(jsonData);
                dag.loadData(nodes, edges, 'hierarchical');
                updateStatus(`æ•°æ®åŠ è½½æˆåŠŸ: ${nodes.length} ä¸ªèŠ‚ç‚¹, ${edges.length} æ¡è¾¹`, 'success');
            } catch (error) {
                updateStatus(`æ— æ³•åŠ è½½çˆ¶ç›®å½•æ•°æ®: ${error.message}`, 'error');
                console.error('æ•°æ®åŠ è½½é”™è¯¯:', error);
            }
        }
        
        function testLayouts() {
            if (dag.nodes.length === 0) {
                updateStatus('è¯·å…ˆåŠ è½½æ•°æ®', 'error');
                return;
            }
            
            const currentIsHierarchical = dag.nodes[0].x % 140 === 70;
            
            if (currentIsHierarchical) {
                dag.calculateGridLayout(dag.nodes);
                updateStatus('å·²åˆ‡æ¢åˆ°ç½‘æ ¼å¸ƒå±€', 'info');
            } else {
                dag.calculateHierarchicalLayout(dag.nodes, dag.edges);
                updateStatus('å·²åˆ‡æ¢åˆ°å±‚æ¬¡å¸ƒå±€', 'info');
            }
            
            dag.render();
        }
        
        function exportData() {
            const config = dag.exportConfiguration();
            if (!config) {
                updateStatus('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º', 'error');
                return;
            }
            
            const dataStr = JSON.stringify(config, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'dag-visualization-config.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            updateStatus('é…ç½®å·²å¯¼å‡º', 'success');
        }
        
        function clearCanvas() {
            dag.clear();
            updateStatus('ç”»å¸ƒå·²æ¸…ç©º', 'info');
        }
    </script>
</body>
</html> 