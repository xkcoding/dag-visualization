<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Flow DAG å¯è§†åŒ–æ”¹è¿›ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .flow-wrapper {
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid #e1e5e9;
            position: relative;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        button {
            background: #1890ff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            font-weight: 500;
        }
        
        button:hover {
            background: #40a9ff;
            transform: translateY(-1px);
        }
        
        .status {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
        }
        
        .status.success { background: #f6ffed; color: #52c41a; border: 1px solid #b7eb8f; }
        .status.error { background: #fff2f0; color: #ff4d4f; border: 1px solid #ffccc7; }
        .status.info { background: #e6f7ff; color: #1890ff; border: 1px solid #91d5ff; }
        
        h1 { color: #262626; margin: 0; }
        h3 { color: #8c8c8c; margin: 5px 0; font-weight: normal; }
        
        /* React Flow è‡ªå®šä¹‰æ ·å¼ */
        .react-flow__node {
            border-radius: 8px;
            padding: 10px;
            border: 2px solid #333;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-weight: 500;
            min-width: 120px;
            text-align: center;
        }
        
        .react-flow__node-prompt {
            background: linear-gradient(135deg, #52c41a, #73d13d);
            color: white;
            border-color: #389e0d;
        }
        
        .react-flow__node-llm {
            background: linear-gradient(135deg, #faad14, #ffc53d);
            color: #000;
            border-color: #d48806;
        }
        
        .react-flow__node-http {
            background: linear-gradient(135deg, #ff4d4f, #ff7875);
            color: white;
            border-color: #cf1322;
        }
        
        .react-flow__node-code {
            background: linear-gradient(135deg, #722ed1, #9254de);
            color: white;
            border-color: #531dab;
        }
        
        .react-flow__edge {
            stroke: #334155;
            stroke-width: 2;
        }
        
        .react-flow__edge.animated {
            stroke-dasharray: 5;
            animation: dashdraw 0.5s linear infinite;
        }
        
        .react-flow__edge-path {
            stroke: #334155;
            stroke-width: 2;
        }
        
        @keyframes dashdraw {
            to {
                stroke-dashoffset: -10;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ React Flow DAG å¯è§†åŒ–æ”¹è¿›ç‰ˆ</h1>
            <h3>çœŸæ­£çš„ DAG å›¾å½¢å¼ï¼Œå…·å¤‡å®Œæ•´äº¤äº’åŠŸèƒ½</h3>
        </div>
        
        <div id="reactflow-container" class="flow-wrapper">
            <!-- React Flow åœ¨è¿™é‡Œæ¸²æŸ“ -->
        </div>
        
        <div class="controls">
            <button onclick="testSimpleDAG()">ç®€å• DAG</button>
            <button onclick="testComplexDAG()">å¤æ‚ DAG (29èŠ‚ç‚¹)</button>
            <button onclick="testDagre()">Dagre å¸ƒå±€</button>
            <button onclick="testForce()">åŠ›å¯¼å‘å¸ƒå±€</button>
            <button onclick="clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button>
            
            <div id="status" class="status info">
                æ­£åœ¨åŠ è½½ React Flow...
            </div>
        </div>
    </div>

    <!-- React å’Œ React Flow -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    
    <script>
        let flowInstance = null;
        let setNodes, setEdges;
        
        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Dagre å¸ƒå±€ç®—æ³•
        function getLayoutedElements(nodes, edges, direction = 'TB') {
            const g = new dagre.graphlib.Graph();
            g.setDefaultEdgeLabel(() => ({}));
            g.setGraph({ rankdir: direction, nodesep: 100, ranksep: 80 });
            
            nodes.forEach((node) => {
                g.setNode(node.id, { width: 150, height: 50 });
            });
            
            edges.forEach((edge) => {
                g.setEdge(edge.source, edge.target);
            });
            
            dagre.layout(g);
            
            const layoutedNodes = nodes.map((node) => {
                const nodeWithPosition = g.node(node.id);
                return {
                    ...node,
                    position: {
                        x: nodeWithPosition.x - 75,
                        y: nodeWithPosition.y - 25,
                    },
                };
            });
            
            return { nodes: layoutedNodes, edges };
        }
        
        // åŠ›å¯¼å‘å¸ƒå±€ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function getForceLayoutElements(nodes, edges) {
            const layoutedNodes = nodes.map((node, index) => {
                const angle = (index / nodes.length) * 2 * Math.PI;
                const radius = Math.min(200, nodes.length * 20);
                return {
                    ...node,
                    position: {
                        x: 300 + Math.cos(angle) * radius,
                        y: 200 + Math.sin(angle) * radius,
                    },
                };
            });
            
            return { nodes: layoutedNodes, edges };
        }
        
        // è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶
        const customNodeTypes = {
            prompt: ({ data }) => {
                return React.createElement('div', {
                    className: 'react-flow__node-prompt',
                    style: {
                        padding: '10px 15px',
                        borderRadius: '8px',
                        border: '2px solid #389e0d',
                        background: 'linear-gradient(135deg, #52c41a, #73d13d)',
                        color: 'white',
                        fontWeight: 'bold',
                        minWidth: '120px',
                        textAlign: 'center',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                    }
                }, data.label);
            },
            llm: ({ data }) => {
                return React.createElement('div', {
                    className: 'react-flow__node-llm',
                    style: {
                        padding: '10px 15px',
                        borderRadius: '8px',
                        border: '2px solid #d48806',
                        background: 'linear-gradient(135deg, #faad14, #ffc53d)',
                        color: '#000',
                        fontWeight: 'bold',
                        minWidth: '120px',
                        textAlign: 'center',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                    }
                }, data.label);
            },
            http: ({ data }) => {
                return React.createElement('div', {
                    className: 'react-flow__node-http',
                    style: {
                        padding: '10px 15px',
                        borderRadius: '8px',
                        border: '2px solid #cf1322',
                        background: 'linear-gradient(135deg, #ff4d4f, #ff7875)',
                        color: 'white',
                        fontWeight: 'bold',
                        minWidth: '120px',
                        textAlign: 'center',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                    }
                }, data.label);
            },
            code: ({ data }) => {
                return React.createElement('div', {
                    className: 'react-flow__node-code',
                    style: {
                        padding: '10px 15px',
                        borderRadius: '8px',
                        border: '2px solid #531dab',
                        background: 'linear-gradient(135deg, #722ed1, #9254de)',
                        color: 'white',
                        fontWeight: 'bold',
                        minWidth: '120px',
                        textAlign: 'center',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                    }
                }, data.label);
            }
        };
        
        window.addEventListener('load', function() {
            initializeReactFlow();
        });
        
        function initializeReactFlow() {
            if (typeof React === 'undefined') {
                updateStatus('âŒ React æœªåŠ è½½', 'error');
                return;
            }
            
            if (typeof ReactFlow === 'undefined') {
                updateStatus('âŒ React Flow æœªåŠ è½½', 'error');
                return;
            }
            
            updateStatus('âœ… React å’Œ React Flow åŠ è½½æˆåŠŸ', 'success');
            
            const { useState, useCallback } = React;
            
            function FlowApp() {
                const [nodes, setNodesState] = useState([]);
                const [edges, setEdgesState] = useState([]);
                
                // æš´éœ² setState å‡½æ•°åˆ°å…¨å±€
                setNodes = setNodesState;
                setEdges = setEdgesState;
                
                const onNodesChange = useCallback((changes) => {
                    setNodesState((nds) => ReactFlow.applyNodeChanges(changes, nds));
                }, []);
                
                const onEdgesChange = useCallback((changes) => {
                    setEdgesState((eds) => ReactFlow.applyEdgeChanges(changes, eds));
                }, []);
                
                const onConnect = useCallback((connection) => {
                    setEdgesState((eds) => ReactFlow.addEdge({
                        ...connection,
                        animated: true,
                        style: { stroke: '#334155', strokeWidth: 2 }
                    }, eds));
                }, []);
                
                return React.createElement(ReactFlow.ReactFlow, {
                    nodes: nodes,
                    edges: edges,
                    onNodesChange: onNodesChange,
                    onEdgesChange: onEdgesChange,
                    onConnect: onConnect,
                    nodeTypes: customNodeTypes,
                    fitView: true,
                    onInit: (instance) => {
                        flowInstance = instance;
                        updateStatus('âœ… React Flow åˆå§‹åŒ–æˆåŠŸï¼å¯ä»¥å¼€å§‹æµ‹è¯•', 'success');
                        // è‡ªåŠ¨åŠ è½½ç®€å•ç¤ºä¾‹
                        setTimeout(() => testSimpleDAG(), 1000);
                    },
                    style: { width: '100%', height: '100%' },
                    nodesDraggable: true,
                    nodesConnectable: true,
                    elementsSelectable: true
                }, [
                    React.createElement(ReactFlow.Controls, { 
                        position: 'bottom-left',
                        style: { left: 10, bottom: 10 }
                    }),
                    React.createElement(ReactFlow.MiniMap, { 
                        position: 'bottom-right',
                        style: { right: 10, bottom: 10, width: 150, height: 100 }
                    }),
                    React.createElement(ReactFlow.Background, { 
                        variant: 'dots',
                        gap: 20,
                        size: 1,
                        color: '#e1e5e9'
                    })
                ]);
            }
            
            const container = document.getElementById('reactflow-container');
            const root = ReactDOM.createRoot(container);
            root.render(React.createElement(FlowApp));
        }
        
        function testSimpleDAG() {
            if (!setNodes || !setEdges) {
                updateStatus('âŒ Flow æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            const simpleNodes = [
                {
                    id: '1',
                    type: 'prompt',
                    position: { x: 100, y: 100 },
                    data: { label: 'PROMPT BUILD' }
                },
                {
                    id: '2',
                    type: 'llm',
                    position: { x: 350, y: 100 },
                    data: { label: 'CALL LLM' }
                },
                {
                    id: '3',
                    type: 'http',
                    position: { x: 600, y: 100 },
                    data: { label: 'HTTP REQUEST' }
                },
                {
                    id: '4',
                    type: 'code',
                    position: { x: 850, y: 100 },
                    data: { label: 'CODE EXEC' }
                }
            ];
            
            const simpleEdges = [
                { 
                    id: 'e1-2', 
                    source: '1', 
                    target: '2', 
                    animated: true,
                    style: { stroke: '#334155', strokeWidth: 2 }
                },
                { 
                    id: 'e2-3', 
                    source: '2', 
                    target: '3', 
                    animated: true,
                    style: { stroke: '#334155', strokeWidth: 2 }
                },
                { 
                    id: 'e3-4', 
                    source: '3', 
                    target: '4', 
                    animated: true,
                    style: { stroke: '#334155', strokeWidth: 2 }
                }
            ];
            
            setNodes(simpleNodes);
            setEdges(simpleEdges);
            
            setTimeout(() => {
                if (flowInstance) flowInstance.fitView();
                updateStatus('âœ… ç®€å• DAG åŠ è½½å®Œæˆ - å¯æ‹–æ‹½èŠ‚ç‚¹æµ‹è¯•äº¤äº’', 'success');
            }, 100);
        }
        
        function testComplexDAG() {
            if (!setNodes || !setEdges) {
                updateStatus('âŒ Flow æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            const complexNodes = [];
            const complexEdges = [];
            
            const nodeTypes = ['prompt', 'llm', 'http', 'code'];
            const nodeLabels = ['PROMPT', 'LLM', 'HTTP', 'CODE'];
            
            // ç”Ÿæˆ 29 ä¸ªèŠ‚ç‚¹
            for (let i = 1; i <= 29; i++) {
                const typeIndex = (i - 1) % 4;
                complexNodes.push({
                    id: `node${i}`,
                    type: nodeTypes[typeIndex],
                    position: { 
                        x: ((i - 1) % 6) * 200 + 50, 
                        y: Math.floor((i - 1) / 6) * 120 + 50 
                    },
                    data: { label: `${nodeLabels[typeIndex]} ${i}` }
                });
            }
            
            // ç”Ÿæˆè¾¹ - åˆ›å»ºçœŸæ­£çš„ DAG ç»“æ„
            for (let i = 1; i < 29; i++) {
                // æ°´å¹³è¿æ¥
                if (i % 6 !== 0 && Math.random() > 0.3) {
                    complexEdges.push({
                        id: `eh${i}-${i+1}`,
                        source: `node${i}`,
                        target: `node${i+1}`,
                        style: { stroke: '#334155', strokeWidth: 2 }
                    });
                }
                // å‚ç›´è¿æ¥
                if (i <= 23 && Math.random() > 0.4) {
                    complexEdges.push({
                        id: `ev${i}-${i+6}`,
                        source: `node${i}`,
                        target: `node${i+6}`,
                        style: { stroke: '#334155', strokeWidth: 2 }
                    });
                }
                // å¯¹è§’è¿æ¥
                if (i % 6 !== 0 && i <= 22 && Math.random() > 0.7) {
                    complexEdges.push({
                        id: `ed${i}-${i+7}`,
                        source: `node${i}`,
                        target: `node${i+7}`,
                        style: { stroke: '#334155', strokeWidth: 2 }
                    });
                }
            }
            
            setNodes(complexNodes);
            setEdges(complexEdges);
            
            setTimeout(() => {
                if (flowInstance) flowInstance.fitView();
                updateStatus('âœ… å¤æ‚ DAG åŠ è½½å®Œæˆ - 29ä¸ªèŠ‚ç‚¹ï¼Œå¯æµ‹è¯•æ€§èƒ½', 'success');
            }, 100);
        }
        
        function testDagre() {
            if (!setNodes || !setEdges || !flowInstance) {
                updateStatus('âŒ Flow æœªå°±ç»ª', 'error');
                return;
            }
            
            const currentNodes = flowInstance.getNodes();
            const currentEdges = flowInstance.getEdges();
            
            if (currentNodes.length === 0) {
                updateStatus('âš ï¸ è¯·å…ˆåŠ è½½æ•°æ®å†æµ‹è¯•å¸ƒå±€', 'error');
                return;
            }
            
            const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(
                currentNodes,
                currentEdges,
                'TB'
            );
            
            setNodes(layoutedNodes);
            setEdges(layoutedEdges);
            
            setTimeout(() => {
                if (flowInstance) flowInstance.fitView();
                updateStatus('âœ… Dagre åˆ†å±‚å¸ƒå±€åº”ç”¨å®Œæˆ', 'success');
            }, 100);
        }
        
        function testForce() {
            if (!setNodes || !setEdges || !flowInstance) {
                updateStatus('âŒ Flow æœªå°±ç»ª', 'error');
                return;
            }
            
            const currentNodes = flowInstance.getNodes();
            const currentEdges = flowInstance.getEdges();
            
            if (currentNodes.length === 0) {
                updateStatus('âš ï¸ è¯·å…ˆåŠ è½½æ•°æ®å†æµ‹è¯•å¸ƒå±€', 'error');
                return;
            }
            
            const { nodes: layoutedNodes, edges: layoutedEdges } = getForceLayoutElements(
                currentNodes,
                currentEdges
            );
            
            setNodes(layoutedNodes);
            setEdges(layoutedEdges);
            
            setTimeout(() => {
                if (flowInstance) flowInstance.fitView();
                updateStatus('âœ… åŠ›å¯¼å‘å¸ƒå±€åº”ç”¨å®Œæˆ', 'success');
            }, 100);
        }
        
        function clearCanvas() {
            if (!setNodes || !setEdges) {
                updateStatus('âŒ Flow æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            setNodes([]);
            setEdges([]);
            updateStatus('ğŸ§¹ ç”»å¸ƒå·²æ¸…ç©º', 'info');
        }
    </script>
</body>
</html> 